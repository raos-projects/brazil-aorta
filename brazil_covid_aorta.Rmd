---
title: "Brazilian Aortic Surgery Outcomes in COVID"
author: "Saieesh Rao"
date: "8/15/2024 - 8/26/2024"
output: html_notebook
---

# Motivation
In this R notebook, we look at data on outcomes after aortic surgery in Brazil before and after the COVID-19 pandemic. Data used here is obtained from the Brazilian public health system which captures roughly ~70% of the Brazilian population. We investigate whether the COVID-19 pandemic adversely affected outcomes after aortic surgery during and after the pandemic.

# Setup
## Libraries
Import the necessary libraries:
```{r, message=FALSE}
library(dplyr)
library(magrittr)
library(purrr)
library(tidyr)
library(epitools)
library(future)
library(furrr)
library(kableExtra)
library(blscrapeR)
library(ggplot2)
library(tibble)
library(rdd)
```
## Data
We define a function to help us import the data:
```{r, message=FALSE, echo=FALSE}
# We have a number of ways to import the data. 
# 
# One way is to import data as a 2xN table where the two rows are pre-COVID and post-COVID, and the N columns are all combinations of the identifiers separated by underscores. This means the data has a lot of columns, and it will be easy to use methods which analyze the data when they are defined across many columns. The import function, 'import_flat', is defined below:

import_flat <- function(.type = c('Open','Endo')) {
  if(!(.type %in% c('Open','Endo'))) {
    warning('invalid type')
  }
  # .filepath = paste0("C:\\Users\\saiee\\OneDrive\\Documents\\_Northwestern Residency\\Research\\Miscellaneous Analyses\\Lopes, Lara\\Brazil COVID Stats ",
  #                   .type,".csv")
  .filepath = paste0("data\\Brazil COVID Stats ",.type,".csv")
  lara = read.csv(.filepath)
  
  lara %<>%
    mutate(PRE = Jan_2017_to_Feb_2020 %>% {gsub(',','',.)}) %>%
    mutate(POST = Mar_2020_to_Apr_2023 %>% {gsub(',','',.)}) %>%
    select(-c(Jan_2017_to_Feb_2020, Mar_2020_to_Apr_2023)) %>%
    mutate(TYPE = toupper(.type)) %>%
    t() %>%
    as_tibble()
  
  names(lara) <- lara %>%
    {paste(.[1,],.[2,],.[3,],.[6,])} %>%
    {gsub(' ','_',.)} %>%
    {gsub('-','_',.)}
  
  lara <- lara[-c(1:3,6),] %>%
    mutate(across(where(is.character), as.numeric))
  
  return(lara)
  
}
```

```{r, message=FALSE}
import <- function(.type = c('Open','Endo')) {
  if(!(.type %in% c('Open','Endo'))) {
    warning('invalid type')
  }
  # .filepath = paste0("C:\\Users\\saiee\\OneDrive\\Documents\\_Northwestern Residency\\Research\\Miscellaneous Analyses\\Lopes, Lara\\Brazil COVID Stats ", .type,".csv")
  .filepath = paste0("data\\Brazil COVID Stats ",.type,".csv")
  lara = read.csv(.filepath)
  
  lara %<>%
    mutate(PRE = Jan_2017_to_Feb_2020 %>% {gsub(',','',.)} %>% as.numeric()) %>%
    mutate(POST = Mar_2020_to_Apr_2023 %>% {gsub(',','',.)} %>% as.numeric()) %>%
    select(-c(Jan_2017_to_Feb_2020, Mar_2020_to_Apr_2023)) %>%
    mutate(TYPE = toupper(.type)) %>%
    as_tibble() %>%
    pivot_longer(cols = c(PRE,POST), names_to = 'PERIOD',values_to = 'VALUE')
  
  varnames <- lara %>% pull(VARIABLE) %>% unique()
  
  lara %<>%
    # filter(VARIABLE %in% c(FREQUENCY,DEATHS)) %>%
    pivot_wider(names_from = VARIABLE, values_from = VALUE) %>%
    mutate(ALIVE = FREQUENCY - DEATHS) %>%
    mutate(MORTALITY_ODDS = DEATHS / ALIVE) %>% 
    pivot_longer(cols = all_of(c(varnames,'ALIVE','MORTALITY_ODDS')), names_to = 'VARIABLE', values_to = 'VALUE')  %>%
    mutate(VARIABLE = as.factor(VARIABLE) %>% as.character(),
           TYPE = as.factor(TYPE) %>% as.character(),
           URGENCY = case_match(URGENCY, 'ALL' ~ 'ALL URGENCY', .default = URGENCY),
           POPULATION = case_match(POPULATION, 'GLOBAL' ~ 'ALL PEOPLE', .default = POPULATION))
  
  return(lara)
}
```

```{r}
import_bymonth <- function(.type = c('open','endo')) {
  if(!(.type %in% c('open','endo'))) {
    warning('invalid type')
  }
  # .filepath = paste0("C:\\Users\\saiee\\OneDrive\\Documents\\_Northwestern Residency\\Research\\Miscellaneous Analyses\\Lopes, Lara\\brazil_aorta_", .type,"_bymonth.csv")
  .filepath = paste0("data\\brazil_aorta_", .type,"_bymonth.csv")
  lara_bymonth = read.csv(.filepath)
  
  lara_bymonth %<>%
    as_tibble()
  
  year_month_titles = lara_bymonth %>% names() %>% .[4:length(.)] %>% substr(start=2,stop=999) %>% as.factor()
  year_month_titles <- factor(year_month_titles, levels = year_month_titles)
  year_month_titles_trimmed = year_month_titles[1:120]
  
  names(lara_bymonth) <- lara_bymonth %>% names() %>% {c(.[1:3], .[4:length(.)]%>%substr(start=2,stop=999))}

    lara_bymonth %<>%
      pivot_longer(cols = {names(.)[4:length(names(.))]}, names_to = 'PERIOD', values_to = 'VALUE') %>% 
      mutate(PERIOD = factor(PERIOD, levels = year_month_titles)) %>% 
      mutate(VALUE = VALUE %>% as.numeric()) %>% 
      mutate(TYPE = toupper(.type)) %>% 
      mutate(POPULATION = POPULATION) %>% 
      filter(PERIOD %in% year_month_titles_trimmed)
  
  return(lara_bymonth)
  
  varnames <- lara_bymonth %>% pull(VARIABLE) %>% unique()
  
  # lara_bymonth %<>%
  #   # filter(VARIABLE %in% c(FREQUENCY,DEATHS)) %>%
  #   pivot_wider(names_from = VARIABLE, values_from = VALUE) #%>%
  #   mutate(ALIVE = FREQUENCY - DEATHS) %>%
  #   mutate(MORTALITY_ODDS = DEATHS / ALIVE) %>% 
  #   pivot_longer(cols = all_of(c(varnames,'ALIVE','MORTALITY_ODDS')), names_to = 'VARIABLE', values_to = 'VALUE')  %>%
  #   mutate(VARIABLE = as.factor(VARIABLE) %>% as.character(),
  #          TYPE = as.factor(TYPE) %>% as.character(),
  #          URGENCY = as.factor(URGENCY) %>% recode('ALL' = 'ALL URGENCY') %>% as.character(),
  #          POPULATION = as.factor(POPULATION) %>% recode('GLOBAL' = 'ALL PEOPLE') %>% as.character())
  # 
  # return(lara_bymonth)
}
```

## Helper Functions
```{r, message=FALSE, echo=FALSE}
# We next define a utility function, 'ob' (short for 'obtain') which allows us to extract the value of a metric from the table created by the 'import' function. This will save us a lot of time and provide clarity when we are repeatedly examining / extracting individual values:

ob <- function(.var, .pop, .urg, .type, .prepost) {
  lara %>%
    filter(VARIABLE %in% .var) %>%
    filter(POPULATION %in% .pop) %>%
    filter(URGENCY %in% .urg) %>%
    filter(TYPE %in% .type) %>%
    filter(PERIOD %in% .prepost) %>%
    pull() %>%
    as.numeric() %>% 
    sum()
}
```

```{r, message=FALSE, echo=FALSE}
# We define another utility function to tidy up the output from the epitools::oddsratio function:

or_prettyprint <- function(.output) {
  .output %>%
    unlist(recursive = FALSE) %>%
    {tribble(
      ~'OR', ~'lower', ~'upper', ~'p.value (chi.square)',
      .[['measure2']], .[['measure4']], .[['measure6']], .[['p.value6']]
    )} 
}
```

We now write a function to analyze the imported data. The output of this function is exactly one row in the resulting data table at the end of this file.
```{r}
# Ensure your 'lara' data frame is structured correctly
# The following script assumes 'lara' has columns: POPULATION, URGENCY, TYPE, PERIOD, VALUE

# Define a function to calculate odds ratios for specific comparisons
calculate_odds_ratio <- function(.population, .urgency, .type, .variable, ref_period = "PRE", new_period = "POST") {
  # Filter data for the specific subgroup, outcome, and comparison
  # and arrange so that the comparison is in the order of the inputted
  # parameters (e.g., ENDO vs OPEN is the inverse of OPEN vs ENDO)
  df_filtered <- lara %>%
    filter(POPULATION %in% .population,
           URGENCY %in% .urgency,
           TYPE %in% .type,
           VARIABLE %in% .variable) %>% 
    arrange(match(POPULATION, .population),
            match(URGENCY, .urgency),
            match(TYPE, .type),
            match(VARIABLE, .variable))
  
  # print(df_filtered)
  
  # Create a contingency table for the specified periods
  contingency_table <- matrix(c(
    df_filtered$VALUE[df_filtered$PERIOD == ref_period],
    df_filtered$VALUE[df_filtered$PERIOD == new_period]
  ), ncol = 2, byrow = TRUE)
  
  # print(contingency_table)
  
  # Calculate the odds ratio using epitools::oddsratio
  tryCatch(
    {
      # print('*')
      # if(.variable == 'MORTALITY_ODDS') {
      #   odds_ratio = (contingency_table[1,1]*contingency_table[2,2])/(contingency_table[1,2]*contingency_table[2,1])
      #   or_result = list(measure = NA, p.value = NA)
      #   or_result$measure <- tribble(
      #     ~estimate, ~upper, ~lower,
      #     NA, NA, NA,
      #     odds_ratio,
      #     exp(log(odds_ratio) + 1.96*sqrt(1/contingency_table[1,1] + 1/contingency_table[1,2] + 1/contingency_table[2,1] + 1/contingency_table[2,2])),
      #     exp(log(odds_ratio) - 1.96*sqrt(1/contingency_table[1,1] + 1/contingency_table[1,2] + 1/contingency_table[2,1] + 1/contingency_table[2,2]))
      #   )
      #   or_result$p.value <- tribble(
      #     ~midp.exact,
      #     NA,
      #     NA
      #   )
      #   print('&')
      #   print(or_result)
      # }
      # else {
      or_result <<- oddsratio(contingency_table)
      #   print('^')
      # }
    },
    error=function (e){
      or_result <<- list(measure = tibble(), p.value = tibble())
      or_result$measure <<- tribble(
        ~estimate, ~upper, ~lower,
        NA, NA, NA,
        NA, NA, NA,
      )
      or_result$p.value <<- tribble(
        ~midp.exact,
        NA,
        NA
      )
      # print(paste('ERROR:',c(.population, .urgency, .type, .variable) %>% unlist()))
      # print(or_result)
    }
  )
  # print(or_result$measure)
  
  # Extract the odds ratio and confidence interval
  or_value <- or_result$measure[2, "estimate"]^-1 #inverse for post/pre
  ci_lower <- or_result$measure[2, "upper"]^-1
  ci_upper <- or_result$measure[2, "lower"]^-1
  p_value <- or_result$p.value[2, "midp.exact"]
  
  #comparison group is the one with more than one value passed as a parameter
  params <- list(.population, .urgency, .type)
  comparison <- params %>%
    lapply(length) %>%
    lapply(function(.x){return(.x > 1)}) %>% 
    unlist() %>% 
    {params[which(.)]} %>% 
    unlist()
  controls <- params %>%
    lapply(length) %>%
    lapply(function(.x){return(.x == 1)}) %>% 
    unlist() %>% 
    {params[which(.)]} %>% 
    unlist() 
  
  ##print(comparison)
  
  return(data.frame(
    Metric = paste(.variable,collapse = '/'),
    Population = paste(controls, collapse = ', '),
    Comparison = case_when(length(comparison) > 1 ~ paste(comparison[1], "vs.", comparison[2]),
                           .default = 'DEATHS vs. ALIVE'),
    Odds_Pre = contingency_table[1,1]/contingency_table[1,2],
    Odds_Post = contingency_table[2,1]/contingency_table[2,2],
    Odds_Ratio = round(or_value, 2),
    CI_95 = paste0("(", round(ci_lower, 2), ", ", round(ci_upper, 2), ")"),
    P_Value = round(p_value, 4),
    Significance = case_when(p_value <= 0.001 ~ '***',
                             p_value <= 0.01 ~ '**',
                             p_value <= 0.05 ~ '*',
                             p_value <= 0.1 ~ '.',
                             .default = '')
  ))
}
```

We now write a quick linear regression function, with output as one row in a table (or two rows if calculating regressions on both sides of a discontinuity):
```{r}
# lm_quick <- function(.data, .variable, .population, .urgency, .type, .predict){
#   
#   # filter data to the specified parameters
#   lm_quick_filter <- function(.data, .variable, .population, .urgency, .type) {
#     .data %<>% 
#       filter(VARIABLE %in% .variable) %>% 
#       filter(!is.na(PERIOD)) %>% 
#       filter(POPULATION %in% .population) %>% 
#       filter(URGENCY %in% .urgency) %>% 
#       filter(TYPE %in% .type) %>% 
#       mutate(TIME = as.integer(PERIOD))
#     return(.data)
#   }
#   
#   # use `rdd` package to determine best fit regressions on each side of the discontinuity
#   lm_quick_rdd <- function(.data, .variable, .population, .urgency, .type, .predict) {
#     
#     .data %<>% lm_quick_filter(.variable, .population, .urgency, .type)
#     
#     rd_model <- RDestimate(VALUE ~ TIME, data = .data, cutpoint = .predict, model = TRUE, kernel = 'rectangular')
#     
#     intercept <- rd_model$model[[1]]$coefficients[["(Intercept)"]]
#     treatment_effect <- rd_model$model[[1]]$coefficients[["Tr"]]
#     slope_left <- rd_model$model[[1]]$coefficients[["Xl"]]
#     slope_right <- rd_model$model[[1]]$coefficients[["Xr"]]
#     p_value <- rd_model$p[1]
#     
#     intercept_left = intercept - slope_left * .predict
#     intercept_right = intercept + treatment_effect - slope_right * .predict
#     
#     IKB <- rd_model$bw[1] #Imbens-Kalyanaraman bandwidth
#     # x_coord <- seq(ceiling(.predict - IKB), floor(.predict + IKB))
#     .data$PREDICTED = NaN
#     .data$PREDICTED = case_when(.data$TIME < .predict ~ intercept_left + slope_left * .data$TIME,
#                                 .data$TIME > .predict ~ intercept_right + slope_right * .data$TIME,
#                                 .default = NA)
#     
#     output_table <-
#       tribble(
#         ~VARIABLE, ~POPULATION, ~URGENCY, ~TYPE, ~Intercept, ~Coefficient, ~PERIOD, ~TREATMENT_EFFECT, ~P.VALUE, ~IK.BANDWIDTH,
#         .variable, .population, .urgency, .type, intercept_left, slope_left, 'PRE', NA, NA, IKB,
#         .variable, .population, .urgency, .type, intercept_right, slope_right, 'POST', treatment_effect, p_value ,IKB
#       )
# 
#     return(list(row = output_table, newdata = .data, ikb = IKB))
#   }
#   
#   # run a basic OLS regression after filtering on the given parameters
#   lm_quick_core <- function(.data, .variable, .population, .urgency, .type) {
#     reg <- .data %>% 
#       filter(VARIABLE %in% .variable) %>% 
#       filter(!is.na(PERIOD)) %>% 
#       filter(POPULATION %in% .population) %>% 
#       filter(URGENCY %in% .urgency) %>% 
#       filter(TYPE %in% .type) %>% 
#       mutate(TIME = as.integer(PERIOD)) %>%
#       {lm(VALUE ~ TIME,.)}
#     
#     output <- 
#       tribble(
#         ~VARIABLE, ~POPULATION, ~URGENCY, ~TYPE, ~Intercept, ~Coefficient,
#         .variable, .population, .urgency, .type, reg$coefficients %>% .['(Intercept)'], reg$coefficients %>% .['TIME']
#       )
#     
#     return(list(row = output, model = reg))
#   }
#   
#   if(is.numeric(.predict)){
#     return(lm_quick_rdd(.data, .variable, .population, .urgency, .type, .predict))
#   } else {
#     return(lm_quick_core(.data, .variable, .population, .urgency, .type) %>% .[['row']])
#   }
# }
```

Function to quickly filter data based on parameters:
```{r}
# filter data to the specified parameters
quick_filter <- function(.data, .variable, .population, .urgency, .type) {
  .data %<>% 
    filter(VARIABLE %in% .variable) %>% 
    filter(!is.na(PERIOD)) %>% 
    filter(POPULATION %in% .population) %>% 
    filter(URGENCY %in% .urgency) %>% 
    filter(TYPE %in% .type) %>% 
    mutate(TIME = as.integer(PERIOD))
  return(.data)
}
```

Utility function for generating linear models, either for summarizing linear results or outputting result of regression discontinuity design:
```{r}
lm_quick <- function(.data, .variable, .population, .urgency, .type, .predict){
  
  # use `rdd` package to determine best fit regressions on each side of the discontinuity.
  # N.B. this now deprecated in favor of manual calculation of IK bandwidth, p-values, etc.
  lm_quick_rdd <- function(.data, .variable, .population, .urgency, .type, .predict) {
    
    .data %<>% quick_filter(.variable, .population, .urgency, .type)
    
    rd_model <- RDestimate(VALUE ~ TIME, data = .data, cutpoint = .predict, model = TRUE, kernel = 'rectangular')
    
    intercept <- rd_model$model[[1]]$coefficients[["(Intercept)"]]
    treatment_effect <- rd_model$model[[1]]$coefficients[["Tr"]]
    slope_left <- rd_model$model[[1]]$coefficients[["Xl"]]
    slope_right <- rd_model$model[[1]]$coefficients[["Xr"]]
    p_value <- rd_model$p[1]
    
    intercept_left = intercept - slope_left * .predict
    intercept_right = intercept + treatment_effect - slope_right * .predict
    
    IKB <- rd_model$bw[1] #Imbens-Kalyanaraman bandwidth
    # x_coord <- seq(ceiling(.predict - IKB), floor(.predict + IKB))
    .data$PREDICTED = NaN
    .data$PREDICTED = case_when(.data$TIME < .predict ~ intercept_left + slope_left * .data$TIME,
                                .data$TIME > .predict ~ intercept_right + slope_right * .data$TIME,
                                .default = NA)
    
    output_table <-
      tribble(
        ~VARIABLE, ~POPULATION, ~URGENCY, ~TYPE, ~Intercept, ~Coefficient, ~PERIOD, ~TREATMENT_EFFECT, ~P.VALUE, ~IK.BANDWIDTH,
        .variable, .population, .urgency, .type, intercept_left, slope_left, 'PRE', NA, NA, IKB,
        .variable, .population, .urgency, .type, intercept_right, slope_right, 'POST', treatment_effect, p_value ,IKB
      )

    return(list(row = output_table, newdata = .data, ikb = IKB))
  }
  
  # run a basic OLS regression after filtering on the given parameters
  lm_quick_core <- function(.data, .variable, .population, .urgency, .type) {
    reg <- .data %>% 
      quick_filter(.variable, .population, .urgency, .type) %>% 
      # filter(VARIABLE %in% .variable) %>% 
      # filter(!is.na(PERIOD)) %>% 
      # filter(POPULATION %in% .population) %>% 
      # filter(URGENCY %in% .urgency) %>% 
      # filter(TYPE %in% .type) %>% 
      mutate(TIME = as.integer(PERIOD)) %>%
      {lm(VALUE ~ TIME,.)}
    
    output <- 
      tribble(
        ~VARIABLE, ~POPULATION, ~URGENCY, ~TYPE, ~Intercept, ~Coefficient, ~R2, ~R2_adjusted,
        .variable, .population, .urgency, .type, reg$coefficients %>% .['(Intercept)'], reg$coefficients %>% .['TIME'], summary(reg)[['r.squared']], summary(reg)[['adj.r.squared']]
      )
    
    return(list(row = output, model = reg))
  }
  
  if(is.numeric(.predict)) {
    
    .data %<>% quick_filter(.variable, .population, .urgency, .type)
    
    .ikb = IKbandwidth(.data$TIME, .data$VALUE, cutpoint = 75, kernel = 'rectangular')
    
    lm_left <- .data %>% subset(TIME < 75 & TIME > 75 - .ikb) %>%
      lm_quick_core(.variable, .population, .urgency, .type)
    
    lm_right <- .data %>% subset(TIME > 75 & TIME < 75 + .ikb) %>%
      lm_quick_core(.variable, .population, .urgency, .type)
    
    pred_left = predict(lm_left$model, newdata = data.frame(TIME = .predict), se.fit = TRUE)
    pred_right = predict(lm_right$model, newdata = data.frame(TIME = .predict), se.fit = TRUE)
    
    treatment_effect = pred_right$fit - pred_left$fit
    se_treatment_effect = sqrt(pred_right$se.fit^2 + pred_left$se.fit^2)
    z_value = treatment_effect / se_treatment_effect
    p_value <- 2 * (1 - pnorm(abs(z_value)))
    
    lm_left$row %<>% mutate(TREATMENT_EFFECT = NA, P.VALUE = NA, IK.BANDWIDTH = .ikb)
    lm_right$row %<>% mutate(TREATMENT_EFFECT = treatment_effect, P.VALUE = p_value, IK.BANDWIDTH = .ikb)
    
    return(list(row = bind_rows(lm_left$row, lm_right$row), newdata = .data, ikb = .ikb))
    # return(lm_quick_rdd(.data, .variable, .population, .urgency, .type, .predict))
  } else {
    return(lm_quick_core(.data, .variable, .population, .urgency, .type) %>% .[['row']])
  }
}
```


Since we wil be using a lot of variables of the same name across code chunks, I write a function to clean them up before starting a new code chunk (prevents logical errors from typos):
```{r}
cleanup <- function(){
  ls(pattern = '^IKB_', envir = .GlobalEnv) %>% {rm(list = ., envir = .GlobalEnv)}
  ls(pattern = '^lara_bymonth_', envir = .GlobalEnv) %>% {rm(list = ., envir = .GlobalEnv)}
  ls(pattern = '^table_row_', envir = .GlobalEnv) %>% {rm(list = ., envir = .GlobalEnv)}
}
```


# Analysis
## Import Data
Lets now actually import both the open surgery and endovascular surgery data sets, and join them in one big table:
```{r}
lara <- bind_rows(import('Open'),
                  import('Endo'))  %>% 
  pivot_wider(names_from = 'TYPE', values_from = 'VALUE') %>% 
  mutate(`ALL APPROACH` = ENDO + OPEN) %>%
  pivot_longer(cols = c('ALL APPROACH','ENDO','OPEN'), names_to = 'TYPE', values_to = 'VALUE')
```


We create a data frame with all possible combinations of parameters that can define two groups we want to compare:
```{r}
# Define the subgroups, outcomes, and comparisons you want to analyze

params_combo <- expand.grid(.population = list('ALL PEOPLE','MALE','FEMALE',c('MALE','FEMALE'),
                            'WHITE','BLACK','PARDA',
                            c('WHITE','BLACK'),c('WHITE','PARDA'),c('BLACK','PARDA')),
                      .urgency = list('ALL URGENCY','URGENT','ELECTIVE',c('URGENT','ELECTIVE')),
                      .type = list('ALL APPROACH','ENDO','OPEN',c('ENDO','OPEN')),
                      .variable = list('FREQUENCY',c('DEATHS','ALIVE')))
```

We narrow these combinations, so that there is only one parameter with two values; these two values will be the subgroups for comparison along with pre-COVID vs. post-COVID comparisons:
```{r}
params_filtered <- params_combo %>%
  rowwise() %>% 
  mutate(across(everything(),
                .fns = ~length(.x),
                .names = '{.col}_n')) %>% 
  filter(.population_n + .urgency_n + .type_n + .variable_n == 5) %>% #.variable_n
  select(-ends_with('_n'))

#calculate odds ratios with parallel computing
plan(multicore, workers = 3)

output <- future_pmap(params_filtered, calculate_odds_ratio, .progress = TRUE)
output %<>% bind_rows() %>% select(-c('estimate','midp.exact'))

output %>% 
  kbl() %>% 
  kable_classic() %>% 
  row_spec(lapply(seq(0,(dim(output)[1]-1)/18),
                  function(.x) {c(4 + 18*.x, 8+18*.x, 12 + 18*.x, 18 + 18*.x)}) %>% unlist(),
           extra_css = "border-bottom: 1px solid")
```

# Figures

Let's now create the requested figures. First let's import the data in by month format, and add a third `TYPE` category combining `OPEN` and `ENDO` called `ALL`:
```{r, warning=FALSE, message=FALSE}
lara_bymonth <- bind_rows(import_bymonth('open'),
                          import_bymonth('endo'))
variable_names <- lara_bymonth$VARIABLE %>% unique()
lara_bymonth %<>% 
  pivot_wider(names_from = TYPE, values_from = VALUE) %>% 
  mutate(ALL = OPEN + ENDO) %>% 
  pivot_longer(cols = c('OPEN','ENDO','ALL'), names_to = 'TYPE') %>%
  rename(VALUE = value) %>% 
  pivot_wider(names_from = VARIABLE, values_from = VALUE) %>% 
  mutate(MORTALITY = DEATHS / FREQUENCY * 100) %>% 
  pivot_longer(cols = variable_names, names_to = 'VARIABLE') %>% 
  rename(VALUE = value)
```
## Figure Group 1. Case Frequency versus Time
We create several figures which demonstrate frequency of surgeries over time:
### Line Plot
```{r, echo=FALSE}
cleanup()
lara_bymonth %>%
  filter(VARIABLE == 'FREQUENCY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(URGENCY != 'ALL') %>% 
  filter(TYPE != 'ALL') %>% 
  group_by(URGENCY, TYPE) %>%
  ggplot(aes(x=PERIOD, y=VALUE, colour = interaction(URGENCY,TYPE), group = interaction(URGENCY,TYPE))) +
  geom_line() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')

lara_bymonth %>%
  filter(VARIABLE == 'FREQUENCY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(URGENCY != 'ALL') %>% 
  filter(TYPE == 'ALL') %>% 
  group_by(URGENCY, TYPE) %>%
  ggplot(aes(x=PERIOD, y=VALUE, colour = URGENCY, group = URGENCY)) +
  geom_line() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')

lara_bymonth %>%
  filter(VARIABLE == 'FREQUENCY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(URGENCY == 'ALL') %>% 
  filter(TYPE != 'ALL') %>% 
  group_by(URGENCY, TYPE) %>%
  ggplot(aes(x=PERIOD, y=VALUE, colour = TYPE, group = TYPE)) +
  geom_line() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')
```
### Bar Chart, Stacked
```{r, echo=FALSE}
cleanup()
lara_bymonth %>%
  filter(VARIABLE == 'FREQUENCY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(URGENCY != 'ALL') %>% 
  filter(TYPE != 'ALL') %>% 
  group_by(URGENCY, TYPE) %>%
  ggplot(aes(x=PERIOD, y=VALUE, fill = interaction(URGENCY,TYPE), group = interaction(URGENCY,TYPE))) +
  geom_bar(position = 'stack', stat='identity') +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')
```

### Bar Chart, Stacked, Normalized to 100%
```{r, echo=FALSE}
cleanup()
lara_bymonth %>%
  filter(VARIABLE == 'FREQUENCY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(URGENCY != 'ALL') %>% 
  filter(TYPE != 'ALL') %>% 
  group_by(URGENCY, TYPE) %>%
  ggplot(aes(x=PERIOD, y=VALUE, fill = interaction(URGENCY,TYPE), group = interaction(URGENCY,TYPE))) +
  geom_bar(position = 'fill', stat='identity') +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')
```
### Scatter Plot, URGENCY, with smoothened average curve (LOESS)
```{r, echo=FALSE}
cleanup()
lara_bymonth %>%
  filter(VARIABLE == 'FREQUENCY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(TYPE == 'ALL') %>%
  group_by(URGENCY) %>%
  ggplot(aes(x=PERIOD, y=VALUE, colour = URGENCY, group = URGENCY)) +
  geom_point() +
  geom_smooth(formula = y~x, method = 'loess') +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')

lara_bymonth %>%
  filter(VARIABLE == 'FREQUENCY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(TYPE == 'ALL') %>%
  group_by(URGENCY) %>%
  ggplot(aes(x=PERIOD, y=VALUE, colour = URGENCY, group = URGENCY)) +
  geom_point() +
  geom_smooth(formula = y ~ x, method = 'lm') +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')

expand.grid(list(.variable = 'FREQUENCY',
                 .population = 'GLOBAL',
                 .urgency = c('ALL','URGENT','ELECTIVE'),
                 .type = c('ALL'),
                 .predict = NA)) %>% 
  pmap(lm_quick, .data=lara_bymonth) %>% 
  bind_rows() %>% 
  kbl() %>% 
  kable_classic()
```
### Scatter Plot, URGENCY & TYPE, with smoothened average curve (LOESS)
```{r, echo=FALSE}
cleanup()
lara_bymonth %>%
  filter(VARIABLE == 'FREQUENCY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(URGENCY != 'ALL') %>%
  filter(TYPE != 'ALL') %>% 
  group_by(URGENCY, TYPE) %>%
  ggplot(aes(x=PERIOD, y=VALUE, colour = interaction(URGENCY,TYPE), group = interaction(URGENCY,TYPE))) +
  geom_point() +
  geom_smooth(formula = y ~ x, method = 'loess') +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')
```
```{r, echo=FALSE}
cleanup()
lara_bymonth %>%
  filter(VARIABLE == 'FREQUENCY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(URGENCY == 'ALL') %>%
  filter(TYPE != 'ALL') %>% 
  group_by(URGENCY, TYPE) %>%
  ggplot(aes(x=PERIOD, y=VALUE, colour = TYPE, group = TYPE)) +
  geom_point() +
  geom_smooth(formula = y ~ x, method = 'loess') +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')
```
### Scatter Plot, URGENCY & TYPE, with linear regression fit and table of coefficients
```{r, echo=FALSE}
cleanup()
lara_bymonth %>%
  filter(VARIABLE == 'FREQUENCY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(URGENCY != 'ALL') %>% 
  filter(TYPE %in% c('ENDO','OPEN')) %>% 
  group_by(URGENCY, TYPE) %>%
  ggplot(aes(x=PERIOD, y=VALUE, colour = interaction(URGENCY,TYPE), group = interaction(URGENCY,TYPE))) +
  geom_point() +
  geom_smooth(formula = y ~ x, method = 'lm') +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')

expand.grid(list(.variable = 'FREQUENCY',
                 .population = 'GLOBAL',
                 .urgency = c('URGENT','ELECTIVE'),
                 .type = c('ENDO','OPEN'),
                 .predict = NA)) %>% 
  pmap(lm_quick, .data=lara_bymonth) %>% 
  bind_rows() %>% 
  kbl() %>% 
  kable_classic()
```

```{r,echo=FALSE}
cleanup()
lara_bymonth %>%
  filter(VARIABLE == 'FREQUENCY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(URGENCY == 'ALL') %>% 
  filter(TYPE != 'ALL') %>% 
  group_by(URGENCY, TYPE) %>%
  ggplot(aes(x=PERIOD, y=VALUE, colour = TYPE, group = TYPE)) +
  geom_point() +
  geom_smooth(formula = y ~ x, method = 'lm') +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')

expand.grid(list(.variable = 'FREQUENCY',
                 .population = 'GLOBAL',
                 .urgency = 'ALL',
                 .type = c('ENDO','OPEN'),
                 .predict = NA)) %>% 
  pmap(lm_quick, .data=lara_bymonth) %>% 
  bind_rows() %>% 
  kbl() %>% 
  kable_classic()
```
### Regression Discontinuity Analysis, FREQUENCY, by URGENCY & TYPE
Here we look at regressions on each side of the COVID pandemic start date and examine for discontinuities. First we examine `FREQUENCY` data for both `URGENCY` and `TYPE`: 
```{r, echo=FALSE, warning=FALSE}
cleanup()
lara_bymonth_urgent_all = lara_bymonth %>%
  lm_quick('FREQUENCY','GLOBAL','URGENT','ALL',75)
table_row_urgent_all = lara_bymonth_urgent_all[['row']]
IKB_urgent_all = lara_bymonth_urgent_all[['ikb']]
lara_bymonth_urgent_all = lara_bymonth_urgent_all[['newdata']]

lara_bymonth_elective_all = lara_bymonth %>%
  lm_quick('FREQUENCY','GLOBAL','ELECTIVE','ALL',75)
table_row_elective_all = lara_bymonth_elective_all[['row']]
IKB_elective_all = lara_bymonth_elective_all[['ikb']]
lara_bymonth_elective_all = lara_bymonth_elective_all[['newdata']]

lara_bymonth_urgent_open = lara_bymonth %>%
  lm_quick('FREQUENCY','GLOBAL','URGENT','OPEN',75)
table_row_urgent_open = lara_bymonth_urgent_open[['row']]
IKB_urgent_open = lara_bymonth_urgent_open[['ikb']]
lara_bymonth_urgent_open = lara_bymonth_urgent_open[['newdata']]

lara_bymonth_elective_open = lara_bymonth %>%
  lm_quick('FREQUENCY','GLOBAL','ELECTIVE','OPEN',75)
table_row_elective_open = lara_bymonth_elective_open[['row']]
IKB_elective_open = lara_bymonth_elective_open[['ikb']]
lara_bymonth_elective_open = lara_bymonth_elective_open[['newdata']]

lara_bymonth_urgent_endo = lara_bymonth %>%
  lm_quick('FREQUENCY','GLOBAL','URGENT','ENDO',75)
table_row_urgent_endo = lara_bymonth_urgent_endo[['row']]
IKB_urgent_endo = lara_bymonth_urgent_endo[['ikb']]
lara_bymonth_urgent_endo = lara_bymonth_urgent_endo[['newdata']]

lara_bymonth_elective_endo = lara_bymonth %>%
  lm_quick('FREQUENCY','GLOBAL','ELECTIVE','ENDO',75)
table_row_elective_endo = lara_bymonth_elective_endo[['row']]
IKB_elective_endo = lara_bymonth_elective_endo[['ikb']]
lara_bymonth_elective_endo = lara_bymonth_elective_endo[['newdata']]

lara_bymonth_all_endo = lara_bymonth %>%
  lm_quick('FREQUENCY','GLOBAL','ALL','ENDO',75)
table_row_all_endo = lara_bymonth_all_endo[['row']]
IKB_all_endo = lara_bymonth_all_endo[['ikb']]
lara_bymonth_all_endo = lara_bymonth_all_endo[['newdata']]

lara_bymonth_all_open = lara_bymonth %>%
  lm_quick('FREQUENCY','GLOBAL','ALL','OPEN',75)
table_row_all_open = lara_bymonth_all_open[['row']]
IKB_all_open = lara_bymonth_all_open[['ikb']]
lara_bymonth_all_open = lara_bymonth_all_open[['newdata']]

# simple LOESS over the entire study period, URGENCY and TYPE combos
ggplot() +
  geom_point(data = bind_rows(lara_bymonth_urgent_open, lara_bymonth_elective_open, lara_bymonth_urgent_endo, lara_bymonth_elective_endo), aes(x=PERIOD, y=VALUE, colour = interaction(URGENCY,TYPE), group = interaction(URGENCY,TYPE))) +
  geom_smooth(data = bind_rows(lara_bymonth_urgent_open, lara_bymonth_elective_open, lara_bymonth_urgent_endo, lara_bymonth_elective_endo), formula = y ~ x, method = 'loess', aes(x=TIME, y=VALUE, colour = interaction(URGENCY,TYPE))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')

# simple OLS over the entire study period, URGENCY and TYPE
ggplot() +
  geom_point(data = bind_rows(lara_bymonth_urgent_open, lara_bymonth_elective_open, lara_bymonth_urgent_endo, lara_bymonth_elective_endo), aes(x=PERIOD, y=VALUE, colour = interaction(URGENCY,TYPE), group = interaction(URGENCY,TYPE))) +
  geom_smooth(data = bind_rows(lara_bymonth_urgent_open, lara_bymonth_elective_open, lara_bymonth_urgent_endo, lara_bymonth_elective_endo), formula = y ~ x, method = 'lm', aes(x=TIME, y=VALUE, colour = interaction(URGENCY,TYPE))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')

expand_grid(.variable = 'FREQUENCY',
            .population = 'GLOBAL',
            .urgency = c('URGENT','ELECTIVE'),
            .type = c('OPEN','ENDO'),
            .predict = NA) %>% 
  pmap(lm_quick, .data=lara_bymonth) %>% 
  bind_rows() %>%
  kbl() %>% 
  kable_classic()

# regression discontinuity limited to IK bandwidth about the cut point, URGENCY and TYPE combos
ggplot() +
  geom_point(data = bind_rows(lara_bymonth_urgent_open, lara_bymonth_elective_open, lara_bymonth_urgent_endo, lara_bymonth_elective_endo), aes(x=PERIOD, y=VALUE, colour = interaction(URGENCY,TYPE), group = interaction(URGENCY,TYPE))) +
  geom_smooth(data = subset(lara_bymonth_urgent_open, TIME < 75 & TIME > 75 - IKB_urgent_open), aes(x=TIME, y=VALUE, color=interaction(URGENCY,TYPE)), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_urgent_open, TIME > 75 & TIME < 75 + IKB_urgent_open), aes(x=TIME, y=VALUE, color=interaction(URGENCY,TYPE)), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_urgent_endo, TIME < 75 & TIME > 75 - IKB_urgent_endo), aes(x=TIME, y=VALUE, color=interaction(URGENCY,TYPE)), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_urgent_endo, TIME > 75 & TIME < 75 + IKB_urgent_endo), aes(x=TIME, y=VALUE, color=interaction(URGENCY,TYPE)), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_elective_open, TIME < 75 & TIME > 75 - IKB_elective_open), aes(x=TIME, y=VALUE, color=interaction(URGENCY,TYPE)), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_elective_open, TIME > 75 & TIME < 75 + IKB_elective_open), aes(x=TIME, y=VALUE, color=interaction(URGENCY,TYPE)), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_elective_endo, TIME < 75 & TIME > 75 - IKB_elective_endo), aes(x=TIME, y=VALUE, color=interaction(URGENCY,TYPE)), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_elective_endo, TIME > 75 & TIME < 75 + IKB_elective_endo), aes(x=TIME, y=VALUE, color=interaction(URGENCY,TYPE)), formula = y ~ x, method = 'lm') +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')

list(table_row_urgent_open, table_row_elective_open, table_row_urgent_endo, table_row_elective_endo) %>% 
  bind_rows() %>%
  kbl() %>% 
  kable_classic()

# simple OLS over the entire study period, URGENCY and all TYPE
ggplot() +
  geom_point(data = bind_rows(lara_bymonth_urgent_all, lara_bymonth_elective_all), aes(x=PERIOD, y=VALUE, colour = URGENCY, group = URGENCY)) +
  geom_smooth(data = bind_rows(lara_bymonth_urgent_all, lara_bymonth_elective_all), formula = y ~ x, method = 'lm', aes(x=TIME, y=VALUE, colour = URGENCY)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')

expand_grid(.variable = 'FREQUENCY',
            .population = 'GLOBAL',
            .urgency = c('URGENT','ELECTIVE'),
            .type = 'ALL',
            .predict = NA) %>% 
  pmap(lm_quick, .data=lara_bymonth) %>% 
  bind_rows() %>%
  kbl() %>% 
  kable_classic()

#simple LOESS over the study period, URGENCY
ggplot() +
  geom_point(data = bind_rows(lara_bymonth_urgent_all, lara_bymonth_elective_all), aes(x=PERIOD, y=VALUE, colour = URGENCY, group = URGENCY)) +
  geom_smooth(data = bind_rows(lara_bymonth_urgent_all, lara_bymonth_elective_all), formula = y ~ x, method = 'loess', aes(x=TIME, y=VALUE, colour = URGENCY)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')

# regression discontinuity limited to IK bandwidth about the cut point, URGENCY with all TYPE
ggplot() +
  geom_point(data = bind_rows(lara_bymonth_urgent_all, lara_bymonth_elective_all), aes(x=PERIOD, y=VALUE, colour = URGENCY, group = URGENCY)) +
  geom_smooth(data = subset(lara_bymonth_urgent_all, TIME < 75 & TIME > 75 - IKB_urgent_all), aes(x=TIME, y=VALUE, color=URGENCY), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_urgent_all, TIME > 75 & TIME < 75 + IKB_urgent_all), aes(x=TIME, y=VALUE, color=URGENCY), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_elective_all, TIME < 75 & TIME > 75 - IKB_elective_all), aes(x=TIME, y=VALUE, color=URGENCY), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_elective_all, TIME > 75 & TIME < 75 + IKB_elective_all), aes(x=TIME, y=VALUE, color=URGENCY), formula = y ~ x, method = 'lm') +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')

list(table_row_urgent_all, table_row_elective_all) %>% 
  bind_rows() %>%
  kbl() %>% 
  kable_classic()

#simple LOESS over the study period, TYPE and all URGENCY
ggplot() +
  geom_point(data = bind_rows(lara_bymonth_all_open, lara_bymonth_all_endo), aes(x=PERIOD, y=VALUE, colour = TYPE, group = TYPE)) +
  geom_smooth(data = bind_rows(lara_bymonth_all_open, lara_bymonth_all_endo), formula = y ~ x, method = 'loess', aes(x=TIME, y=VALUE, colour = TYPE)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')

# simple OLS over the entire study period, TYPE and all URGENCY
ggplot() +
  geom_point(data = bind_rows(lara_bymonth_all_open, lara_bymonth_all_endo), aes(x=PERIOD, y=VALUE, colour = TYPE, group = TYPE)) +
  geom_smooth(data = bind_rows(lara_bymonth_all_open, lara_bymonth_all_endo), formula = y ~ x, method = 'lm', aes(x=TIME, y=VALUE, colour = TYPE)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')

expand_grid(.variable = 'FREQUENCY',
            .population = 'GLOBAL',
            .urgency = 'ALL',
            .type = c('OPEN','ENDO'),
            .predict = NA) %>% 
  pmap(lm_quick, .data=lara_bymonth) %>% 
  bind_rows() %>%
  kbl() %>% 
  kable_classic()

# regression discontinuity limited to IK bandwidth about the cut point, TYPE with all URGENCY
ggplot() +
  geom_point(data = bind_rows(lara_bymonth_all_open, lara_bymonth_all_endo), aes(x=PERIOD, y=VALUE, colour = TYPE, group = TYPE)) +
  geom_smooth(data = subset(lara_bymonth_all_open, TIME < 75 & TIME > 75 - IKB_all_open), aes(x=TIME, y=VALUE, color=TYPE), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_all_open, TIME > 75 & TIME < 75 + IKB_all_open), aes(x=TIME, y=VALUE, color=TYPE), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_all_endo, TIME < 75 & TIME > 75 - IKB_all_endo), aes(x=TIME, y=VALUE, color=TYPE), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_all_endo, TIME > 75 & TIME < 75 + IKB_all_endo), aes(x=TIME, y=VALUE, color=TYPE), formula = y ~ x, method = 'lm') +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')

list(table_row_all_open, table_row_all_endo) %>% 
  bind_rows() %>%
  kbl() %>% 
  kable_classic()
```


```{r, echo=FALSE, message=FALSE, results=FALSE, warning=FALSE, include=TRUE}
# cleanup()
# lara_bymonth %>%
#   filter(VARIABLE == 'FREQUENCY') %>%
#   filter(!is.na(PERIOD)) %>% 
#   filter(POPULATION == 'GLOBAL') %>% 
#   filter(URGENCY != 'ALL') %>% 
#   filter(TYPE != 'ALL') %>% 
#   group_by(URGENCY, TYPE) %>%
#   {ggplot(.,aes(x=PERIOD, y=VALUE, colour = interaction(URGENCY,TYPE), group = interaction(URGENCY,TYPE))) +
#   geom_point() +
#   geom_smooth(data = subset(., as.integer(PERIOD) < 75 & as.integer(PERIOD) > 75 - invisible(IKbandwidth(X = as.integer(PERIOD), Y = VALUE, cutpoint = 75, verbose = T, kernel = "triangular"))), formula = y ~ x, method = 'lm') +
#   geom_smooth(data = subset(., as.integer(PERIOD) > 75 & as.integer(PERIOD) < 75 + invisible(IKbandwidth(X = as.integer(PERIOD), Y = VALUE, cutpoint = 75, verbose = T, kernel = "triangular"))), formula = y ~ x, method = 'lm') +
#   theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
#   scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
#   geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
#   geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
#   labs(x='Month',y='Frequency')}
# 
# invisible(c(
#   expand.grid(list(.variable = 'FREQUENCY',
#                  .population = 'GLOBAL',
#                  .urgency = c('URGENT','ELECTIVE'),
#                  .type = c('OPEN','ENDO'),
#                  .predict = 75)) %>% 
#   pmap(lm_quick, .data=subset(lara_bymonth, as.integer(PERIOD) < 75 & as.integer(PERIOD) > 75 - IKbandwidth(X = as.integer(PERIOD), Y = VALUE, cutpoint = 75, verbose = T, kernel = "triangular"))),
#   expand.grid(list(.variable = 'FREQUENCY',
#                  .population = 'GLOBAL',
#                  .urgency = c('URGENT','ELECTIVE'),
#                  .type = c('OPEN','ENDO'),
#                  .predict = 75)) %>% 
#   pmap(lm_quick, .data=subset(lara_bymonth, as.integer(PERIOD) > 75 & as.integer(PERIOD) < 75 + IKbandwidth(X = as.integer(PERIOD), Y = VALUE, cutpoint = 75, verbose = T, kernel = "triangular")))
#   )) %>% 
#   bind_rows() %>%
#   add_column(PERIOD = c(rep('PRE',4),rep('POST',4)), .after = 'TYPE') %>% 
#   kbl() %>% 
#   kable_classic()
```
### Regression Discontinuity Analysis, URGENCY
```{r, echo=FALSE}
cleanup()
lara_bymonth %>%
  filter(VARIABLE == 'FREQUENCY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(URGENCY != 'ALL') %>% 
  filter(TYPE == 'ALL') %>% 
  group_by(URGENCY, TYPE) %>%
  {ggplot(.,aes(x=PERIOD, y=VALUE, colour = URGENCY, group = URGENCY)) +
  geom_point() +
  geom_smooth(data = subset(., as.integer(PERIOD) < 75 & as.integer(PERIOD) > 75 - IKbandwidth(X = as.integer(PERIOD), Y = VALUE, cutpoint = 75, verbose = T, kernel = "triangular")), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(., as.integer(PERIOD) > 75 & as.integer(PERIOD) < 75 + IKbandwidth(X = as.integer(PERIOD), Y = VALUE, cutpoint = 75, verbose = T, kernel = "triangular")), formula = y ~ x, method = 'lm') +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')}

c(
  expand.grid(list(.variable = 'FREQUENCY',
                 .population = 'GLOBAL',
                 .urgency = c('URGENT','ELECTIVE'),
                 .type = 'ALL',
                 .predict = 75)) %>% 
  pmap(lm_quick, .data=subset(lara_bymonth, as.integer(PERIOD) < 75 & as.integer(PERIOD) > 75 - IKbandwidth(X = as.integer(PERIOD), Y = VALUE, cutpoint = 75, verbose = T, kernel = "triangular"))),
  expand.grid(list(.variable = 'FREQUENCY',
                 .population = 'GLOBAL',
                 .urgency = c('URGENT','ELECTIVE'),
                 .type = 'ALL',
                 .predict = 75)) %>% 
  pmap(lm_quick, .data=subset(lara_bymonth, as.integer(PERIOD) > 75 & as.integer(PERIOD) < 75 + IKbandwidth(X = as.integer(PERIOD), Y = VALUE, cutpoint = 75, verbose = T, kernel = "triangular")))
  ) %>% 
  bind_rows() %>%
  add_column(PERIOD = c('PRE','PRE','POST','POST'), .after = 'TYPE') %>% 
  kbl() %>% 
  kable_classic()
```


## Figure Group 2. 30-Day Mortality versus Time
```{r, echo=FALSE}
cleanup()
lara_bymonth %>%
  filter(VARIABLE == 'MORTALITY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(URGENCY != 'ALL') %>% 
  filter(TYPE != 'ALL') %>% 
  group_by(URGENCY, TYPE) %>%
  ggplot(aes(x=PERIOD, y=VALUE/100, colour = interaction(URGENCY,TYPE), group = interaction(URGENCY,TYPE))) +
  geom_line() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Mortality')

lara_bymonth %>%
  filter(VARIABLE == 'MORTALITY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(URGENCY != 'ALL') %>% 
  filter(TYPE == 'ALL') %>% 
  group_by(URGENCY, TYPE) %>%
  ggplot(aes(x=PERIOD, y=VALUE/100, colour = URGENCY, group = URGENCY)) +
  geom_line() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Mortality')

lara_bymonth %>%
  filter(VARIABLE == 'MORTALITY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(URGENCY == 'ALL') %>% 
  filter(TYPE != 'ALL') %>% 
  group_by(URGENCY, TYPE) %>%
  ggplot(aes(x=PERIOD, y=VALUE/100, colour = TYPE, group = TYPE)) +
  geom_line() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Mortality')
```
### Regression Discontinuity Analysis, Mortality, URGENCY & TYPE
```{r, echo=FALSE, warning=FALSE}
cleanup()
lara_bymonth_urgent_all = lara_bymonth %>%
  lm_quick('MORTALITY','GLOBAL','URGENT','ALL',75)
table_row_urgent_all = lara_bymonth_urgent_all[['row']]
IKB_urgent_all = lara_bymonth_urgent_all[['ikb']]
lara_bymonth_urgent_all = lara_bymonth_urgent_all[['newdata']]

lara_bymonth_elective_all = lara_bymonth %>%
  lm_quick('MORTALITY','GLOBAL','ELECTIVE','ALL',75)
table_row_elective_all = lara_bymonth_elective_all[['row']]
IKB_elective_all = lara_bymonth_elective_all[['ikb']]
lara_bymonth_elective_all = lara_bymonth_elective_all[['newdata']]

lara_bymonth_urgent_open = lara_bymonth %>%
  lm_quick('MORTALITY','GLOBAL','URGENT','OPEN',75)
table_row_urgent_open = lara_bymonth_urgent_open[['row']]
IKB_urgent_open = lara_bymonth_urgent_open[['ikb']]
lara_bymonth_urgent_open = lara_bymonth_urgent_open[['newdata']]

lara_bymonth_elective_open = lara_bymonth %>%
  lm_quick('MORTALITY','GLOBAL','ELECTIVE','OPEN',75)
table_row_elective_open = lara_bymonth_elective_open[['row']]
IKB_elective_open = lara_bymonth_elective_open[['ikb']]
lara_bymonth_elective_open = lara_bymonth_elective_open[['newdata']]

lara_bymonth_urgent_endo = lara_bymonth %>%
  lm_quick('MORTALITY','GLOBAL','URGENT','ENDO',75)
table_row_urgent_endo = lara_bymonth_urgent_endo[['row']]
IKB_urgent_endo = lara_bymonth_urgent_endo[['ikb']]
lara_bymonth_urgent_endo = lara_bymonth_urgent_endo[['newdata']]

lara_bymonth_elective_endo = lara_bymonth %>%
  lm_quick('MORTALITY','GLOBAL','ELECTIVE','ENDO',75)
table_row_elective_endo = lara_bymonth_elective_endo[['row']]
IKB_elective_endo = lara_bymonth_elective_endo[['ikb']]
lara_bymonth_elective_endo = lara_bymonth_elective_endo[['newdata']]

# simple OLS over the entire study period, URGENCY and TYPE
ggplot() +
  geom_point(data = bind_rows(lara_bymonth_urgent_open, lara_bymonth_elective_open, lara_bymonth_urgent_endo, lara_bymonth_elective_endo), aes(x=PERIOD, y=VALUE/100, colour = interaction(URGENCY,TYPE), group = interaction(URGENCY,TYPE))) +
  geom_smooth(data = bind_rows(lara_bymonth_urgent_open, lara_bymonth_elective_open, lara_bymonth_urgent_endo, lara_bymonth_elective_endo), formula = y ~ x, method = 'lm', aes(x=TIME, y=VALUE/100, colour = interaction(URGENCY,TYPE))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Mortality')

expand_grid(.variable = 'MORTALITY',
            .population = 'GLOBAL',
            .urgency = c('URGENT','ELECTIVE'),
            .type = c('OPEN','ENDO'),
            .predict = NA) %>% 
  pmap(lm_quick, .data=lara_bymonth) %>% 
  bind_rows() %>%
  kbl() %>% 
  kable_classic()

# simple LOESS over the entire study period, URGENCY and TYPE combos
ggplot() +
  geom_point(data = bind_rows(lara_bymonth_urgent_open, lara_bymonth_elective_open, lara_bymonth_urgent_endo, lara_bymonth_elective_endo), aes(x=PERIOD, y=VALUE/100, colour = interaction(URGENCY,TYPE), group = interaction(URGENCY,TYPE))) +
  geom_smooth(data = bind_rows(lara_bymonth_urgent_open, lara_bymonth_elective_open, lara_bymonth_urgent_endo, lara_bymonth_elective_endo), formula = y ~ x, method = 'loess', aes(x=TIME, y=VALUE/100, colour = interaction(URGENCY,TYPE))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Mortality')

# regression discontinuity limited to IK bandwidth about the cut point, URGENCY and TYPE combos
ggplot() +
  geom_point(data = bind_rows(lara_bymonth_urgent_open, lara_bymonth_elective_open, lara_bymonth_urgent_endo, lara_bymonth_elective_endo), aes(x=PERIOD, y=VALUE/100, colour = interaction(URGENCY,TYPE), group = interaction(URGENCY,TYPE))) +
  geom_smooth(data = subset(lara_bymonth_urgent_open, TIME < 75 & TIME > 75 - IKB_urgent_open), aes(x=TIME, y=VALUE/100, color=interaction(URGENCY,TYPE)), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_urgent_open, TIME > 75 & TIME < 75 + IKB_urgent_open), aes(x=TIME, y=VALUE/100, color=interaction(URGENCY,TYPE)), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_urgent_endo, TIME < 75 & TIME > 75 - IKB_urgent_endo), aes(x=TIME, y=VALUE/100, color=interaction(URGENCY,TYPE)), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_urgent_endo, TIME > 75 & TIME < 75 + IKB_urgent_endo), aes(x=TIME, y=VALUE/100, color=interaction(URGENCY,TYPE)), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_elective_open, TIME < 75 & TIME > 75 - IKB_elective_open), aes(x=TIME, y=VALUE/100, color=interaction(URGENCY,TYPE)), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_elective_open, TIME > 75 & TIME < 75 + IKB_elective_open), aes(x=TIME, y=VALUE/100, color=interaction(URGENCY,TYPE)), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_elective_endo, TIME < 75 & TIME > 75 - IKB_elective_endo), aes(x=TIME, y=VALUE/100, color=interaction(URGENCY,TYPE)), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_elective_endo, TIME > 75 & TIME < 75 + IKB_elective_endo), aes(x=TIME, y=VALUE/100, color=interaction(URGENCY,TYPE)), formula = y ~ x, method = 'lm') +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Mortality')

list(table_row_urgent_open, table_row_elective_open, table_row_urgent_endo, table_row_elective_endo) %>% 
  bind_rows() %>%
  kbl() %>% 
  kable_classic()

# simple OLS over the entire study period, URGENCY and all TYPE
ggplot() +
  geom_point(data = bind_rows(lara_bymonth_urgent_all, lara_bymonth_elective_all), aes(x=PERIOD, y=VALUE/100, colour = URGENCY, group = URGENCY)) +
  geom_smooth(data = bind_rows(lara_bymonth_urgent_all, lara_bymonth_elective_all), formula = y ~ x, method = 'lm', aes(x=TIME, y=VALUE/100, colour = URGENCY)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Mortality')

expand_grid(.variable = 'MORTALITY',
            .population = 'GLOBAL',
            .urgency = c('URGENT','ELECTIVE'),
            .type = 'ALL',
            .predict = NA) %>% 
  pmap(lm_quick, .data=lara_bymonth) %>% 
  bind_rows() %>%
  kbl() %>% 
  kable_classic()

#simple LOESS over the study period, URGENCY
ggplot() +
  geom_point(data = bind_rows(lara_bymonth_urgent_all, lara_bymonth_elective_all), aes(x=PERIOD, y=VALUE/100, colour = URGENCY, group = URGENCY)) +
  geom_smooth(data = bind_rows(lara_bymonth_urgent_all, lara_bymonth_elective_all), formula = y ~ x, method = 'loess', aes(x=TIME, y=VALUE/100, colour = URGENCY)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Mortality')

# regression discontinuity limited to IK bandwidth about the cut point, URGENCY with all TYPE
ggplot() +
  geom_point(data = bind_rows(lara_bymonth_urgent_all, lara_bymonth_elective_all), aes(x=PERIOD, y=VALUE/100, colour = URGENCY, group = URGENCY)) +
  geom_smooth(data = subset(lara_bymonth_urgent_all, TIME < 75 & TIME > 75 - IKB_urgent_all), aes(x=TIME, y=VALUE/100, color=URGENCY), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_urgent_all, TIME > 75 & TIME < 75 + IKB_urgent_all), aes(x=TIME, y=VALUE/100, color=URGENCY), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_elective_all, TIME < 75 & TIME > 75 - IKB_elective_all), aes(x=TIME, y=VALUE/100, color=URGENCY), formula = y ~ x, method = 'lm') +
  geom_smooth(data = subset(lara_bymonth_elective_all, TIME > 75 & TIME < 75 + IKB_elective_all), aes(x=TIME, y=VALUE/100, color=URGENCY), formula = y ~ x, method = 'lm') +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Mortality')

list(table_row_urgent_all, table_row_elective_all) %>% 
  bind_rows() %>%
  kbl() %>% 
  kable_classic()
```

### Regression Discontinuity Analysis, Mortality, URGENCY only
```{r, echo=FALSE, warning=FALSE}
lara_bymonth_urgent = lara_bymonth %>%
  lm_quick('MORTALITY','GLOBAL','URGENT','ALL',75)
table_row_urgent = lara_bymonth_urgent[['row']]
# IKB_urgent = lara_bymonth_urgent[['ikb']]
# lara_bymonth_urgent = lara_bymonth_urgent[['newdata']]

lara_bymonth_elective = lara_bymonth %>%
  lm_quick('MORTALITY','GLOBAL','ELECTIVE','ALL',75)
table_row_elective = lara_bymonth_elective[['row']]
# IKB_elective = lara_bymonth_elective[['ikb']]
# lara_bymonth_elective = lara_bymonth_elective[['newdata']]

lara_bymonth_all = lara_bymonth %>%
  lm_quick('MORTALITY','GLOBAL','ALL','ALL',75)
table_row_all = lara_bymonth_all[['row']]
# IKB_all = lara_bymonth_all[['ikb']]
# lara_bymonth_all = lara_bymonth_all[['newdata']]

# simple OLS over the entire study period
ggplot() +
  geom_point(data = bind_rows(lara_bymonth_urgent, lara_bymonth_elective, lara_bymonth_all), aes(x=PERIOD, y=VALUE/100, colour = URGENCY, group = URGENCY)) +
  geom_smooth(data = lara_bymonth_urgent, formula = y ~ x, method = 'lm', aes(x=TIME, y=VALUE/100, colour = URGENCY)) +
  geom_smooth(data = lara_bymonth_elective, formula = y ~ x, method = 'lm', aes(x=TIME, y=VALUE/100, colour = URGENCY)) +
  geom_smooth(data = lara_bymonth_all, formula = y ~ x, method = 'lm', aes(x=TIME, y=VALUE/100, colour = URGENCY)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Mortality')

expand_grid(.variable = 'MORTALITY',
            .population = 'GLOBAL',
            .urgency = c('URGENT','ELECTIVE','ALL'),
            .type = 'ALL',
            .predict = NA) %>% 
  pmap(lm_quick, .data=lara_bymonth) %>% 
  bind_rows() %>%
  kbl() %>% 
  kable_classic()

# simple LOESS over the entire study period
ggplot() +
  geom_point(data = bind_rows(lara_bymonth_urgent, lara_bymonth_elective, lara_bymonth_all), aes(x=PERIOD, y=VALUE/100, colour = URGENCY, group = URGENCY)) +
  geom_smooth(data = lara_bymonth_urgent, formula = y ~ x, method = 'loess', aes(x=TIME, y=VALUE/100, colour = URGENCY)) +
  geom_smooth(data = lara_bymonth_elective, formula = y ~ x, method = 'loess', aes(x=TIME, y=VALUE/100, colour = URGENCY)) +
  geom_smooth(data = lara_bymonth_all, formula = y ~ x, method = 'loess', aes(x=TIME, y=VALUE/100, colour = URGENCY)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Mortality')

# regression discontinuity limited to IK bandwidth about the cut point
ggplot() +
  geom_point(data = bind_rows(lara_bymonth_urgent, lara_bymonth_elective, lara_bymonth_all), aes(x=PERIOD, y=VALUE/100, colour = URGENCY, group = URGENCY)) +
  geom_line(data = subset(bind_rows(lara_bymonth_urgent, lara_bymonth_elective, lara_bymonth_all), TIME < 75 & TIME > 75 - IKB_urgent), aes(x=TIME, y=PREDICTED/100, color=URGENCY), linewidth = 2) +
  geom_line(data = subset(bind_rows(lara_bymonth_urgent, lara_bymonth_elective, lara_bymonth_all), TIME > 75 & TIME < 75 + IKB_urgent), aes(x=TIME, y=PREDICTED/100, color=URGENCY), linewidth = 2) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Mortality')

list(table_row_urgent, table_row_elective, table_row_all) %>% 
  bind_rows() %>%
  kbl() %>% 
  kable_classic()
```


### 30-Day Mortality, TYPE only
```{r, echo=FALSE}
lara_bymonth %>%
  filter(VARIABLE == 'MORTALITY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(URGENCY == 'ALL') %>% 
  filter(TYPE != 'ALL') %>% 
  group_by(URGENCY, TYPE) %>%
  ggplot(aes(x=PERIOD, y=VALUE/100, colour = TYPE, group = TYPE)) +
  geom_line() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Mortality')
```
### Regression Discontinuity Analysis, TYPE only
```{r, echo=FALSE}
lara_bymonth_open = lara_bymonth %>%
  filter(VARIABLE == 'MORTALITY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(URGENCY == 'ALL') %>% 
  filter(TYPE == 'OPEN') 
IKB_open = lara_bymonth_open %>% 
  {IKbandwidth(X = as.integer(.$PERIOD), Y = .$VALUE, cutpoint = 75, verbose = T, kernel = "triangular")}

lara_bymonth_endo = lara_bymonth %>%
  filter(VARIABLE == 'MORTALITY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(URGENCY == 'ALL') %>% 
  filter(TYPE == 'ENDO')
IKB_endo = lara_bymonth_endo %>% 
  {IKbandwidth(X = as.integer(.$PERIOD), Y = .$VALUE, cutpoint = 75, verbose = T, kernel = "triangular")}

lara_bymonth_all = lara_bymonth %>%
  filter(VARIABLE == 'MORTALITY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION == 'GLOBAL') %>% 
  filter(URGENCY == 'ALL') %>% 
  filter(TYPE == 'ALL') 
IKB_all = lara_bymonth_all %>% 
  {IKbandwidth(X = as.integer(.$PERIOD), Y = .$VALUE, cutpoint = 75, verbose = T, kernel = "triangular")}

ggplot() +
  geom_point(data = bind_rows(lara_bymonth_open, lara_bymonth_endo, lara_bymonth_all), aes(x=PERIOD, y=VALUE/100, colour = TYPE, group = TYPE)) +
  geom_smooth(data = subset(lara_bymonth_open, as.integer(PERIOD) < 75 & as.integer(PERIOD) > 75 - IKB_open), formula = y ~ x, method = 'lm', aes(x=as.integer(PERIOD), y=VALUE/100, colour = TYPE)) +
  geom_smooth(data = subset(lara_bymonth_open, as.integer(PERIOD) > 75 & as.integer(PERIOD) < 75 + IKB_open), formula = y ~ x, method = 'lm', aes(x=as.integer(PERIOD), y=VALUE/100, colour = TYPE)) +
  geom_smooth(data = subset(lara_bymonth_endo, as.integer(PERIOD) < 75 & as.integer(PERIOD) > 75 - IKB_endo), formula = y ~ x, method = 'lm', aes(x=as.integer(PERIOD), y=VALUE/100, colour = TYPE)) +
  geom_smooth(data = subset(lara_bymonth_endo, as.integer(PERIOD) > 75 & as.integer(PERIOD) < 75 + IKB_endo), formula = y ~ x, method = 'lm', aes(x=as.integer(PERIOD), y=VALUE/100, colour = TYPE)) + 
  geom_smooth(data = subset(lara_bymonth_all, as.integer(PERIOD) < 75 & as.integer(PERIOD) > 75 - IKB_all), formula = y ~ x, method = 'lm', aes(x=as.integer(PERIOD), y=VALUE/100, colour = TYPE)) +
  geom_smooth(data = subset(lara_bymonth_all, as.integer(PERIOD) > 75 & as.integer(PERIOD) < 75 + IKB_all), formula = y ~ x, method = 'lm', aes(x=as.integer(PERIOD), y=VALUE/100, colour = TYPE)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Mortality')

expand_grid(.variable = 'MORTALITY',
            .population = 'GLOBAL',
            .urgency = 'ALL',
            .type = c('OPEN','ENDO','ALL'),
            .predict = 75) %>% 
  add_column(.ikbandwidth = c(IKB_open, IKB_endo, IKB_all)) %>% 
  pmap(lm_quick, .data=lara_bymonth) %>% 
  bind_rows() %>%
  # add_column(PERIOD = c(rep('PRE',3),rep('POST',3)), .after = 'TYPE') %>% 
  kbl() %>% 
  kable_classic()
```

## Figure 3. Case Frequency versus Time By Population Subgroup
Filter by most represented racial groups:
```{r, echo=FALSE}
lara_bymonth %>%
  filter(VARIABLE == 'FREQUENCY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION %in% c('WHITE','BLACK','ASIAN','"PARDA"')) %>% 
  filter(URGENCY != 'ALL') %>% 
  group_by(URGENCY, TYPE) %>%
  ggplot(aes(x=PERIOD, y=VALUE, colour = POPULATION, group = POPULATION)) +
  geom_line() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')
```
Filter by sex:
```{r, echo=FALSE}
lara_bymonth %>%
  filter(VARIABLE == 'FREQUENCY') %>%
  filter(!is.na(PERIOD)) %>% 
  filter(POPULATION %in% c('MALE','FEMALE')) %>% 
  filter(URGENCY != 'ALL') %>% 
  group_by(URGENCY, TYPE) %>%
  ggplot(aes(x=PERIOD, y=VALUE, colour = POPULATION, group = POPULATION)) +
  geom_line() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Month',y='Frequency')
```

## Figure 4. Mortality by Population Subgroup, 2014-2023
```{r, echo=FALSE}
lara_bymonth %>% 
  filter(VARIABLE %in% c('FREQUENCY','DEATHS')) %>% 
  filter(URGENCY != 'ALL') %>% 
  filter(POPULATION %in% c('GLOBAL','WHITE','BLACK','"PARDA"','MALE','FEMALE')) %>% 
  mutate(VALUE = if_else(is.na(VALUE), 0, VALUE)) %>% 
  group_by(POPULATION, URGENCY, TYPE, VARIABLE) %>% 
  summarise(TOTAL = sum(VALUE)) %>%
  pivot_wider(names_from = VARIABLE, values_from = TOTAL) %>% 
  mutate(MORTALITY = DEATHS/FREQUENCY) %>% 
  ggplot() +
  geom_col(aes(x=interaction(POPULATION, URGENCY, TYPE), y=MORTALITY)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(x='Group',y='Mortality')
```

## Figure 5. Endo versus Open Repair by Population Subgroup, 2014-2023
```{r}
lara_bymonth %>% 
  filter(VARIABLE %in% c('FREQUENCY')) %>% 
  filter(URGENCY != 'ALL') %>% 
  filter(POPULATION %in% c('GLOBAL','WHITE','BLACK','"PARDA"','MALE','FEMALE')) %>% 
  mutate(VALUE = if_else(is.na(VALUE), 0, VALUE)) %>% 
  group_by(POPULATION, URGENCY, TYPE, VARIABLE) %>% 
  summarise(TOTAL = sum(VALUE)) %>%
  # pivot_wider(names_from = TYPE, values_from = TOTAL) %>%
  # mutate(TOTAL = ENDO + OPEN) %>%
  # mutate(pENDO = ENDO / TOTAL) %>% 
  # mutate(pOPEN = OPEN / TOTAL) %>% 
  ggplot(aes(fill = TYPE, x=interaction(POPULATION, URGENCY), y=TOTAL)) +
  geom_bar(position = 'fill', stat='identity') +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(x='Group',y='Proportion')
```

## Figure 6. Mortality Before and After COVID
```{r, echo=FALSE}
year_month_titles <- lara_bymonth %>% pull(PERIOD) %>% unique()

lara_bymonth %>%
  filter(VARIABLE %in% c('DEATHS','FREQUENCY')) %>%
  filter(!is.na(PERIOD)) %>%
  filter(POPULATION == 'GLOBAL') %>%
  filter(URGENCY != 'ALL') %>%
  mutate(AFTER_COVID = (as.integer(PERIOD) >= as.integer(year_month_titles[75]))) %>% #[75] == 'Mar_2020'
  mutate(VALUE = if_else(is.na(VALUE), 0, VALUE)) %>% 
  group_by(URGENCY, TYPE, AFTER_COVID, VARIABLE) %>%
  summarise(TOTAL = sum(VALUE)) %>%
  pivot_wider(names_from = VARIABLE, values_from = TOTAL) %>% 
  mutate(MORTALITY = DEATHS/FREQUENCY) %>%  
  print() %>% 
  ggplot(aes(x=interaction(URGENCY,TYPE,AFTER_COVID), y=MORTALITY, fill = interaction(URGENCY,TYPE,AFTER_COVID))) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_discrete(breaks = unique(lara_bymonth$PERIOD)[seq(1, 123, by = 6)]) +
  geom_vline(xintercept = "2020_Mar", linetype = "dashed", color = "black", size = 1) +
  geom_vline(xintercept = "2023_Abr", linetype = "dashed", color = "black", size = 1) +
  labs(x='Subgroup',y='Mortality')
```

